This is my old Windows exploit for the infamous "sysret" vulnerability, which is a quirky design choice in Intel processors. Basically, if the kernel called `sysret` with a non-canonical `RIP`, it would cause an exception. However, the tricky part is that the exception handler gets called with `RSP` already switched to the user process. Back in the day, most operating systems were not aware of this issue and didn't handle it correctly.

Initially, people exploited this flaw by redirecting the user `RSP` to a location they could smash, usually the IDT. Personally, I never really liked that approach. Instead, I took advantage of the fact that `GS` points to user due to the `swapgs` instruction before `sysret`. By performing thread-spraying to fill the `GS`-pointed area and with a few manipulations, I managed to trick the kernel's exception handler into jumping to a `NULL` address, which a the time, Windows even allowed mapping to it, so it was a piece of cake!

Just to make the whole exploit uglier, I decided to write it in C++ ;)
